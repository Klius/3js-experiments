<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>03-Test Configurador</title>
		<style>
			body { margin: 0; overflow:hidden;}
			canvas { width: 100%;height:100%; }
			#material-top{
				position:absolute;
				right: 40%;
			}
			#material-bottom{
				position:absolute;
				bottom:0;
				bottom: 15px;
				right: 40%;
			}
			label{
				margin-right:10px;
			}
			.load-screen{
				position:absolute;
				width:100%;
				height:100%;
				background-color:#bbb;
				display: flex;
				align-items: center;
				justify-content: center;
				flex-direction: column;
				z-index:100;
			}
			@keyframes fade-out {
			  0%   {opacity:1;}
			  75%  {opacity:0;}
			  100% {display:none important!; opacity:0; z-index:-1;}
			}
			.fadeOut{
				animation-name: fade-out;
				animation-duration: 2s;
				animation-fill-mode: forwards;
			}
		</style>
	</head>
	<body>
		<div id="loading" class="load-screen">
			<div>
				<span>Cargando</span></br>
				<img src="assets/ajax-loader.gif"/>
			</div>
		</div>
		<div id="material-top">
			<label>Modelo</label>
			<select id="modelSelect" onchange="loadModel(this.value)">
			</select>
			<label for="color-1">Color</label><input id="color-1" name="color1" class="jscolor {onFineChange:'changeColor(this)'}" value="ffffff"/>
			<label>Material</label>
			<select id="materialSelect" onchange="changeMaterial(this.value)">
			</select>
		</div>
		<div id="material-bottom">
			<label>Second Material</label>
			<select id="secondMaterialSelect" onchange="changeSecondMaterial(this.value)">
			</select>
			<label for="color-2">Color</label><input name="color-2" id="color-2" class="jscolor {onFineChange:'changeColor(this,true)'}" value="ffffff"/>
		</div>
		<div id="viewport"></div>
		<script src="src/lib/jscolor.js"></script>
		<script src="src/lib/three.js"></script>
		<script src="src/lib/webgl.js"></script>
		<script src="src/lib/OrbitControls.js"></script>
		<script src="src/lib/GLTFLoader.js"></script>
		<script>
			var loadCount = 0;
			var objCount = 3;
			var modelSelect = document.getElementById("modelSelect");
			var materialSelect = document.getElementById("materialSelect");
			var secondMaterialSelect = document.getElementById("secondMaterialSelect");
			var objects ={
				'table':{
					'name':'table',
					'src':'assets/models/03/table/scene.gltf',
					'addGround':true,
					'groundPos':  new THREE.Vector3( 0, -1, 5 ),
					'castShadow': true,
					'colorMaterial':'Wood',
					'materials':{
						wood:{
							'src':'assets/models/03/table/textures/Wood_baseColor.jpeg'
						},
						zebra:{
							'src':'assets/models/03/table/textures/Wood_zebraColor.jpeg'
						},
						'void':{
							'src':'assets/models/03/table/textures/tile-void.png'
						},
						weird:{
							'src':'assets/models/03/table/textures/weird-wood.png'
						},
						granite:{
							'src':'assets/models/03/table/textures/granite.png'
						}
					}
				},
				'car':{
					'name':'car',
					'src':'assets/models/03/car/scene.gltf',
					'addGround':true,
					'castShadow': true,
					'groundPos' :  new THREE.Vector3( 0, -4, 0 ),
					'objectScale': new THREE.Vector3( 0.01, 0.01, 0.01 ),
					'colorMaterial':'paint',
					'secondMaterial':'black_paint',
					'materials':{
						'none':{
							'src':'assets/models/03/car/textures/none.png'
						},
						'void':{
							'src':'assets/models/03/car/textures/tile-void.png'
						},
						zebra:{
							'src':'assets/models/03/table/textures/Wood_zebraColor.jpeg'
						},
					},
					'secondaryMaterials':{
						'none':{
							'src':'assets/models/03/car/textures/none.png',
							roughnessMap:'assets/models/03/car/textures/black_matte_metallicRoughness.png'
						},
						metallic:{
							'src':'assets/models/03/marbleTable/textures/metallic.png',
							'roughnessMap':'assets/models/03/marbleTable/textures/metallic_metallicRoughness.png'
						}
					}
				},
				marbleTable:{
					'name':'marbleTable',
					'src':'assets/models/03/marbleTable/scene.gltf',
					'addGround':true,
					'castShadow': true,
					'groundPos' :  new THREE.Vector3( 0, -4, 0 ),
					'objectScale': new THREE.Vector3( 0.04, 0.04, 0.04 ),
					'colorMaterial':'marble',
					'secondMaterial':'wood',
					'materials':{
						'marble':{
							'src':'assets/models/03/marbleTable/textures/marble_baseColor.jpeg',
							'roughnessMap':'assets/models/03/marbleTable/textures/marble_metallicRoughness.png',
							'normalMap':'assets/models/03/marbleTable/textures/marble_normal.png'
						},
						metallic:{
							'src':'assets/models/03/marbleTable/textures/metallic.png',
							'roughnessMap':'assets/models/03/marbleTable/textures/metallic_metallicRoughness.png',
							'normalMap':'assets/models/03/marbleTable/textures/metallic_normal.png'
						},
						granite:{
							'src':'assets/models/03/marbleTable/textures/granite.png',
							'roughnessMap':'assets/models/03/marbleTable/textures/granite_roughnessMap.png',
							'normalMap':'assets/models/03/marbleTable/textures/granite_normal.png'
						}
					},
					'secondaryMaterials':{
						'wood':{
							'src':'assets/models/03/marbleTable/textures/wood_baseColor.jpeg',
							'roughnessMap':'assets/models/03/marbleTable/textures/wood_metallicRoughness.png',
							'normalMap':'assets/models/03/marbleTable/textures/wood_normal.png'
						},
						'stones':{
							'src':'assets/models/03/marbleTable/textures/stones.png',
							'roughnessMap':'assets/models/03/marbleTable/textures/stones_roughnessMap.png',
							'normalMap':'assets/models/03/marbleTable/textures/stones_normal.png'
						},
						metallic:{
							'src':'assets/models/03/marbleTable/textures/metallic.png',
							'roughnessMap':'assets/models/03/marbleTable/textures/metallic_metallicRoughness.png',
							'normalMap':'assets/models/03/marbleTable/textures/metallic_normal.png'
						}
					}
				}
			};
			var loadedObjects = {};
			var scene,camera,renderer,controls,ambientLight,gridHelper,spotLight,loader,oldObject;
			function init(){
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xbbbbbb );
				scene.fog = new THREE.FogExp2( 0xbbbbbb, 0.009);//0.0050 );
				camera = new THREE.PerspectiveCamera(75,window.innerWidth/ window.innerHeight,0.1,1000);
				camera.position.set(10,10,-3); // Set position like this
				camera.lookAt(new THREE.Vector3(0,0,0)); // Set look at coordinate like this
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				document.getElementById("viewport").appendChild( renderer.domElement );
				controls = new THREE.OrbitControls(camera,renderer.domElement);
				controls.autoRotate = true;
				controls.update();
				/*LIGHTS*/
				ambientLight = new THREE.AmbientLight( 0xffffff, 0.1 );
				scene.add( ambientLight );
				
				var directionalLight = new THREE.DirectionalLight( 0xdddddd, 4 );
				directionalLight.position.set( 0, 0, 1 ).normalize();
				scene.add( directionalLight );
				
				spotLight = new THREE.SpotLight( 0xffffff ,1);
				spotLight.position.set( 0, 20, 0 );
				spotLight.intensity = 2;
				spotLight.angle = 0.50;
				spotLight.decay = 2;
				spotLight.penumbra = 0.75;
				spotLight.castShadow = true;

				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;

				spotLight.shadow.camera.near = 500;
				spotLight.shadow.camera.far = 4000;
				spotLight.shadow.camera.fov = 30;
				
				scene.add( spotLight );
				lightHelper = new THREE.SpotLightHelper( spotLight );
				scene.add( lightHelper );
				//ambientLight = new THREE.AmbientLight( 0x404040 ); // soft white light
				//scene.add( ambientLight );
				var size = 10;
				var divisions = 10;
				gridHelper = new THREE.GridHelper( size, divisions );
				scene.add( gridHelper );
				loader = new THREE.GLTFLoader();
				oldObject = "table";
				loadModels();
				populateModels();
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function populateModels(){
				for (obj in objects){
					var option = document.createElement("OPTION");
					option.value = obj;
					option.text = obj;
					modelSelect.add(option);
				}
			}
			
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				//animation stuff goes here
				controls.update();
				renderer.render( scene, camera );
			}
			function changeColor(picker,secondary){
				model = scene.getObjectByName(oldObject);
				
				model.traverse ( ( o ) => {
					if ( o.isMesh ) {
						if (secondary){
							if (o.material.name == objects[oldObject].secondMaterial){
							console.log(o);
							  // note: for a multi-material mesh, `o.material` may be an array,
							  // in which case you'd need to set `.map` on each value.
							o.material.color.setHex("0x"+picker.toString());
							}
						}
						else{
							if (o.material.name == objects[oldObject].colorMaterial){
							console.log(o);
							  // note: for a multi-material mesh, `o.material` may be an array,
							  // in which case you'd need to set `.map` on each value.
							o.material.color.setHex("0x"+picker.toString());
							}
						}
					}
				 });
			}
			function changeMaterial(id){
				info = objects[oldObject];
				obj = loadedObjects[oldObject];
				obj.traverse( ( o ) => {
					if ( o.isMesh ) {
						if (o.material.name == info.colorMaterial){
							console.log(info.materials[id].src);
							o.material.map = THREE.ImageUtils.loadTexture( info.materials[id].src );
							if (info.materials[id].roughnessMap){
								o.material.roughnessMap = THREE.ImageUtils.loadTexture( info.materials[id].roughnessMap );
							}
							if( info.materials[id].normalMap){
								o.material.normalMap = THREE.ImageUtils.loadTexture( info.materials[id].normalMap );
							}
							console.log(o.material);
							o.material.needsUpdate = true;
						}
					}
				 });
			}
			function changeSecondMaterial(id){
				info = objects[oldObject];
				obj = loadedObjects[oldObject];
				obj.traverse( ( o ) => {
					if ( o.isMesh ) {
						if (o.material.name == info.secondMaterial){
							o.material.map = THREE.ImageUtils.loadTexture( info.secondaryMaterials[id].src );
							if (info.secondaryMaterials[id].roughnessMap){
								o.material.roughnessMap = THREE.ImageUtils.loadTexture( info.secondaryMaterials[id].roughnessMap );
							}
							if( info.secondaryMaterials[id].normalMap){
								o.material.normalMap = THREE.ImageUtils.loadTexture( info.secondaryMaterials[id].normalMap );
							}
							o.material.needsUpdate = true;
						}
					}
				 });
			}
			function loadModel(id){
				var remObject = scene.getObjectByName( oldObject );
				var ground = scene.getObjectByName("ground");
				scene.remove(ground);
				scene.remove(remObject);
				sceneInfo = objects[id];
				obj = loadedObjects[id];
				oldObject = id;
				obj.traverse( function ( node ) {
					if ( node.isMesh || node.isLight ){ node.castShadow = true;}
				});
				if ( sceneInfo.addGround ) {
					var groundMaterial = new THREE.MeshPhongMaterial( { color: 0x999999 } );
					var ground = new THREE.Mesh( new THREE.PlaneBufferGeometry( 512, 512 ), groundMaterial );
					ground.name="ground";
					ground.receiveShadow = true;
					if ( sceneInfo.groundPos ) {
						ground.position.copy( sceneInfo.groundPos );
					} else {
						ground.position.z = - 70;
					}
					ground.rotation.x = - Math.PI / 2;
					scene.add( ground );
				}
				if ( sceneInfo.objectScale ) {
						obj.scale.copy( sceneInfo.objectScale );
				}
				scene.add(obj);
				loadMaterials(sceneInfo);
				loadSecondMaterials(sceneInfo);
			}
			function loadMaterials(info){
				for (i=materialSelect.options.length -1;i>-1;i--){
					materialSelect.options.remove(i);
				}
				for (mat in info.materials){
					var option = document.createElement("OPTION");
					option.value = mat;
					option.text = mat;
					materialSelect.add(option);
				}
			}
			function loadSecondMaterials(info){
				for (i=secondMaterialSelect.options.length -1;i>-1;i--){
					secondMaterialSelect.options.remove(i);
				}
				if (info.secondaryMaterials){
					for (mat in info.secondaryMaterials){
						var option = document.createElement("OPTION");
						option.value = mat;
						option.text = mat;
						secondMaterialSelect.add(option);
					}
				}
			}
			function loadModels(){
				for (obj in objects) {
					console.log(obj);
					loader.load(
						objects[obj].src,
						function(gltf){
							//gltf.scene.name = objects[obj].name;
							loadedObjects[gltf.scene.name] = gltf.scene;
							if (gltf.scene.name == "table"){loadModel("table");}
							loadCount += 1;
							if (loadCount == objCount){
								document.getElementById("loading").className +=" fadeOut";
							}
						},
						function ( xhr ) {
							console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
						},function(error){
						console.error(error);
						}
					);
				}
			}
			init();
			animate();
		</script>
	</body>
</html>